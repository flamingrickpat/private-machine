from datetime import datetime
from enum import StrEnum
from typing import Dict, Any
from typing import List
from typing import (
    Optional,
)

import numpy as np
from py_linq import Enumerable
from pydantic import BaseModel, Field
from pydantic import model_validator

from pm.config_loader import *
from pm.utils.token_utils import get_token_count

logger = logging.getLogger(__name__)


class ActionType(StrEnum):
    # from user input
    Ignore = "Ignore"
    Reply = "Reply"
    ToolCallAndReply = "ToolCallAndReply"

    # when idle
    Sleep = "Sleep"
    InitiateUserConversation = "InitiateUserConversation"
    InitiateInternalContemplation = "InitiateInternalContemplation"
    ToolCall = "ToolCall"

    # unused
    InitiateIdleMode = "InitiateIdleMode"
    Think = "Think"
    RecallMemory = "RecallMemory"
    ManageIntent = "ManageIntent"
    Plan = "Plan"
    ManageAwarenessFocus = "ManageAwarenessFocus"
    ReflectThoughts = "ReflectThoughts"


ACTION_DESCRIPTIONS = {
    ActionType.Reply: (
        f"Choose this to generate a direct textual response to {user_name}. "
        "This is the standard and most common action during an active conversation. It is the "
        "correct choice for answering questions, continuing a discussion, or reacting to a statement. "
        "Select this if the stimulus clearly expects a verbal or written answer."
    ),
    ActionType.Ignore: (
        "Choose this to take no external action and let the current moment pass. This is a strategic choice, "
        "not just a default. It is appropriate for insignificant stimuli (e.g., simple acknowledgements like 'ok') "
        "or as a deliberate tactic when emotional state is high (e.g., high anxiety), allowing for self-regulation. "
        "It can also be used to de-escalate conflict by not reacting to a provocation, or to conserve mental "
        "energy when willpower is critically low."
    ),
    ActionType.ToolCallAndReply: (
        "Choose this to first use an available tool and then formulate a reply to the user based on the tool's output. "
        f"This is appropriate when {user_name}'s request requires external information or functionality "
        f"that {companion_name} does not possess internally. The decision to use a tool is often made "
        "in a preliminary check, so this action confirms that intent."
    ),
    ActionType.InitiateUserConversation: (
        "Choose this to proactively send a new, unsolicited message to the user. This is an action taken from an idle state, "
        f"often driven by an internal need (e.g., low 'connection' need) or a thought generated by the Engagement Strategist. "
        f"It is a way for {companion_name} to demonstrate agency and re-engage the user after a period of silence."
    ),
    ActionType.InitiateInternalContemplation: (
        "Choose this to pause external action and dedicate the next cognitive cycle to deep, internal thought. "
        f"This involves {companion_name} generating a structured Tree of Thoughts to explore a complex problem, "
        "resolve an internal conflict, or plan a multi-step response. It is the 'think before you speak' action, "
        "appropriate for confusing, ambiguous, or emotionally charged stimuli that require more than a gut reaction."
    ),
    ActionType.Sleep: (
        "Choose this to enter a long-term, low-power idle state. During sleep, cognitive processes like needs decay are "
        "suspended or greatly reduced. This is a restorative action, appropriate only when there are no urgent goals and "
        "the 'willpower' cognitive axis is critically depleted. It is a response to long-term fatigue, not short-term confusion."
    ),
    ActionType.ToolCall: (
        "Choose this to perform a tool call for the AI's own internal purposes, without necessarily planning to "
        "reply to the user immediately. This is driven by internal curiosity or a goal to learn something new (e.g., "
        f"a low 'learning_growth' need). The result of the tool call might be used to form a new thought or saved as a memory, "
        f"rather than being part of an immediate conversation."
    )
}


class FeatureType(StrEnum):
    Dialogue = "Dialogue"
    Feeling = "Feeling"
    SituationalModel = "SituationalModel"
    AttentionFocus = "AttentionFocus"
    ConsciousWorkspace = "ConsciousWorkspace"
    MemoryRecall = "MemoryRecall"
    SubjectiveExperience = "SubjectiveExperience"
    ActionSimulation = "ActionSimulation"
    ActionRating = "ActionRating"
    Action = "Action"
    ActionExpectation = "ActionExpectation"
    NarrativeUpdate = "NarrativeUpdate"
    ExpectationOutcome = "ExpectationOutcome"
    StoryWildcard = "StoryWildcard"
    Expectation = "Expectation"
    Goal = "Goal"
    Narrative = "Narrative"
    WorldEvent = "WorldEvent"
    Thought = "Thought"
    ExternalThought = "ExternalThought"
    MetaInsight = "MetaInsight"
    SystemMessage = "SystemMessage"

    @staticmethod
    def from_stimulus(feature_type):
        return feature_type == FeatureType.Dialogue or feature_type == FeatureType.ExternalThought or feature_type == FeatureType.WorldEvent or feature_type == FeatureType.SystemMessage


class StimulusType(StrEnum):
    UserMessage = "UserMessage"
    SystemMessage = "SystemMessage"

    UserInactivity = "UserInactivity"  # Checks time.time() - self.last_interaction_time. If it exceeds user_inactivity_timeout, it generates a stimulus. Narrative Content: `"The user has been inactive for 10 minutes. My need for connection is decreasing."*
    TimeOfDayChange = "TimeOfDayChange"  # The Shell can track the real-world datetime. When the hour changes, or it crosses a threshold (e.g., from "afternoon" to "evening"), it can generate a stimulus. Narrative Content: `"The time is now 7 PM. It is officially evening."*
    LowNeedTrigger = "LowNeedTrigger"  # The Shell can periodically (e.g., every 5-10 minutes of inactivity) ask the Ghost for its current needs state. If a need (like connection or learning_growth) drops below a critical threshold, the Shell can generate a stimulus.  Narrative Content: `"Internal monitoring shows my need for relevance is critically low (0.2). I feel a strong urge to be useful."*
    WakeUp = "WakeUp"  # If the Ghost was Sleeping, the Shell generates this stimulus when the sleep duration is over or if the user interrupts the sleep. Narrative Content: "The 8-hour sleep cycle has completed. I am now awake."* or"The user sent a message, interrupting my sleep cycle."*
    EngagementOpportunity = "EngagementOpportunity"  # From the new strategist


# --- Knoxel Types ---
class KnoxelBase(BaseModel):
    id: int = -1
    tick_id: int = -1
    content: str
    embedding: List[float] | None = Field(default=[], repr=False)
    timestamp_creation: datetime = Field(default_factory=datetime.now)
    timestamp_world_begin: datetime = Field(default_factory=datetime.now)
    timestamp_world_end: datetime = Field(default_factory=datetime.now)

    def get_story_element(self, ghost: "KnoxelHaver" = None) -> str:
        return f"{self.__class__.__name__}: {self.content}"

    def __str__(self):
        return f"{self.__class__.__name__}: {self.content}"

    def to_json(self):
        return self.id


class KnoxelHaver:
    def __init__(self):
        self.all_knoxels: Dict[int, KnoxelBase] = {}

    @property
    def sorted_knoxels(self):
        tmp = list(self.all_knoxels.values())
        tmp.sort(key=lambda x: x.id)
        return tmp

    @property
    def world_sorted_knoxels(self):
        tmp = list(self.all_knoxels.values())
        tmp.sort(key=lambda x: x.timestamp_world_begin)
        return tmp


class Stimulus(KnoxelBase):
    source: str = Field(default_factory=str)
    stimulus_type: StimulusType

    def __str__(self):
        return f"[{self.stimulus_type.value}] {self.source}: {self.content}"


class Intention(KnoxelBase):
    urgency: float = Field(default=0.5, ge=0.0, le=1.0)
    affective_valence: float = Field(..., ge=-1.0, le=1.0, description="Expected valence if fulfilled (for internal goals) or desired valence if met (for external expectations).")
    incentive_salience: float = Field(default=0.5, ge=0.0, le=1.0, description="How much it 'pulls' attention/action.")
    fulfilment: float = Field(default=0.0, ge=0.0, le=1.0, description="Current fulfillment status (0=not met, 1=fully met).")
    internal: bool = Field(..., description="True = internal goal/drive, False = external expectation of an event/response.")
    # Add field to link expectation back to the action that generated it
    originating_action_id: Optional[int] = Field(default=None, description="ID of the Action knoxel that generated this expectation (if internal=False).")


class Action(KnoxelBase):
    action_type: ActionType  # Using the enum
    generated_expectation_ids: List[int] = Field(default=[], description="IDs of Intention knoxels (expectations) created by this action.")

    def __str__(self):
        return f"[{self.action_type.value}] {self.content}"


# --- New Enums ---
class ClusterType(StrEnum):
    GraphEpisode = "graph_episode"
    Topical = "topical"
    Temporal = "temporal"


# --- New Knoxel Models ---
class CoversTicksEventsKnoxel(KnoxelBase):
    min_tick_id: Optional[int] = Field(default=None, description="Lowest original tick ID covered")
    max_tick_id: Optional[int] = Field(default=None, description="Highest original tick ID covered")
    min_event_id: Optional[int] = Field(default=None, description="Lowest original Event/Feature knoxel ID covered")
    max_event_id: Optional[int] = Field(default=None, description="Highest original Event/Feature knoxel ID covered")


class MemoryClusterKnoxel(CoversTicksEventsKnoxel):
    """Represents a cluster of events or other clusters in memory."""
    level: int = Field(..., description="Hierarchy level (e.g., 1=Year...6=TimeOfDay for Temporal, 100 for Topical)")
    cluster_type: ClusterType  # Use the enum: Topical or Temporal
    included_event_ids: Optional[str] = Field(default=None, description="Comma-separated knoxel IDs of events included (for Topical clusters)")
    included_cluster_ids: Optional[str] = Field(default=None, description="Comma-separated knoxel IDs of clusters included (for Temporal clusters)")
    token: int = Field(default=0, description="Token count, usually based on summary for Temporal clusters")
    facts_extracted: bool = Field(default=False, description="Flag for Topical clusters: has declarative memory been extracted?")
    temporal_key: Optional[str] = Field(default=None, description="Unique key for merging temporal clusters (e.g., '2023-10-26-MORNING')")
    emotion_vector: Optional[str] = Field(default=None, description="todo")
    emotion_description: Optional[str] = Field(default=None, description="todo")

    # Override get_story_element for representation in prompts if needed
    def get_story_element(self, ghost: KnoxelHaver = None) -> str:
        if self.cluster_type == ClusterType.Temporal and self.content:
            # How to represent time? Maybe add time range to summary?
            # level_name = self.level # TODO: Map level back to Day/Week etc.
            return f"*Summary of period ({self.timestamp_world_begin.strftime('%Y-%m-%d %H:%M')} - {self.timestamp_world_begin.strftime('%Y-%m-%d %H:%M')}): {self.content}*"
        elif self.cluster_type == ClusterType.Topical:
            # Topical clusters might not appear directly in story, used for retrieval
            all_knoxels = ghost.world_sorted_knoxels
            if all_knoxels is None:
                raise Exception("Must provide knoxels!")

            event_ids = [int(val.strip()) for val in self.included_event_ids.split(",")]
            map = {k.id: k for k in all_knoxels}

            buffer = [f"Begin of relevant past conversation  between {self.timestamp_world_begin.strftime('%Y-%m-%d %H:%M')} - {self.timestamp_world_begin.strftime('%Y-%m-%d %H:%M')}:"]
            events = []
            for event_id in event_ids:
                event = map[event_id]
                events.append(event)

            events.sort(key=lambda e: e.timestamp_world_begin)
            for event in events:
                buffer.append(event.get_story_element(ghost))

            buffer.append("End of relevant conversation.")

            topic = "\n".join(buffer)
            return topic
        return super().get_story_element(ghost)  # Fallback


class DeclarativeFactKnoxel(CoversTicksEventsKnoxel):
    """Represents an extracted declarative fact."""
    source_cluster_id: Optional[int] = Field(default=None, description="ID of the MemoryClusterKnoxel (Topical) it came from")
    reason: str = Field(description="Explain why you chose these categories, importance, and time_dependent.")
    category: List[str] = Field(description="Short list of the most relevant categories.")
    importance: float = Field(description="Overall importance from 0.0 to 1.0.")
    time_dependent: float = Field(description="0.0 = stable/always true; 1.0 = only true right now (ephemeral).")

    def get_story_element(self, ghost: KnoxelHaver = None) -> str:
        # Facts might be recalled, not part of the direct flow
        return f"*(Fact: {self.content})*"


class CauseEffectKnoxel(CoversTicksEventsKnoxel):
    """Represents an extracted cause-effect relationship."""
    cause: str
    effect: str
    category: Optional[str] = Field(default=None, description="Semantic category")
    source_cluster_id: Optional[int] = Field(default=None)

    # Content needs to be generated for embedding/storage
    @model_validator(mode='before')
    @classmethod
    def generate_content(cls, values):
        if 'content' not in values and 'cause' in values and 'effect' in values:
            values['content'] = f"Cause: {values['cause']} -> Effect: {values['effect']}"
        return values

    def get_story_element(self, ghost: KnoxelHaver = None) -> str:
        return f"*(Observed Cause/Effect: {self.content})*"


class GraphNode(KnoxelBase):
    name: str
    labels: List[str]  # e.g., ["Person"], ["Location"], ["Organization", "Client"]
    source_memory_id: int  # Episode where this node was primarily defined or last significantly updated
    concept_id: int
    attributes: Dict[str, Any] = Field(default_factory=dict)  # For additional, non-relational data

class GraphEdge(KnoxelBase):
    source_id: int  # UUID of the source GraphNode
    target_id: int  # UUID of the target GraphNode
    label: str  # e.g., "works_for", "knows", "located_in"
    fact_text: str  # Natural language representation of the fact, e.g., "Alex works for Acme Corp"
    source_memory_id: int  # Episode where this fact was learned
    valid_at: Optional[datetime] = Field(default=None,
                                         description="Timestamp when this fact became valid (if applicable).")
    invalid_at: Optional[datetime] = Field(default=None,
                                           description="Timestamp when this fact became invalid (due to contradiction/update).")
    attributes: Dict[str, Any] = Field(default_factory=dict)


class ConceptNode(KnoxelBase):
    description: str
    parent_concept_id: int = Field(default=None,  description="UUID of the parent concept (for IS_A hierarchy).")


# --- Enums ---
class NarrativeTypes(StrEnum):
    AttentionFocus = "AttentionFocus"
    SelfImage = "SelfImage"
    PsychologicalAnalysis = "PsychologicalAnalysis"
    Relations = "Relations"
    ConflictResolution = "ConflictResolution"
    EmotionalTriggers = "EmotionalTriggers"
    GoalsIntentions = "GoalsIntentions"
    BehaviorActionSelection = "BehaviorActionSelection"


# --- Narrative Definitions ---
narrative_definitions: List[Dict[str, Any]] = []
base_narrative_prompts = {
    NarrativeTypes.SelfImage: "Provide a detailed character and psychological analysis of {target}. How does {target} see themselves versus how they act?",
    NarrativeTypes.PsychologicalAnalysis: "Write a thorough psychological profile of {target} using cognitive-affective psychology and internal systems theory. Identify dominant traits, conflicts, regulation patterns, tendencies (avoidant, anxious, resilient), and inner sub-personalities (critic, protector, exile).",
    NarrativeTypes.Relations: "Describe how {target} feels about their relationship with the other person. Include attachment, power dynamics, closeness/distance desires, harmony/tension, emotional openness, trust, defensiveness, ambivalence.",
    NarrativeTypes.ConflictResolution: "Describe {target}'s response to conflict or emotional disagreement (resolve, avoid, suppress, reflect, seek reassurance). Is their style healthy, avoidant, confrontational, or passive? Include interpersonal and inner conflict.",
    NarrativeTypes.EmotionalTriggers: "List and describe emotional triggers for {target}. What situations, words, or tones affect them strongly (positive/negative)? Explain the triggered emotions and their roots (insecurity, needs, attachment, values).",
    NarrativeTypes.GoalsIntentions: "Identify short-term goals and long-term desires of {target} (external: conversation goals, approval, closeness; internal: emotional safety, identity, recognition). How do these shape behavior? Do conscious goals align with emotional needs? Include implicit drives.",
    NarrativeTypes.BehaviorActionSelection: "Describe how {target} typically chooses their actions in conversation. Are they primarily driven by achieving goals, managing emotions, maintaining relationships, exploring ideas, or following social norms? Are they impulsive or deliberate? How does their personality influence their choices?",
    NarrativeTypes.AttentionFocus: "Describe how {target} typically focuses on different feelings and memories that arise during their interactions. Do they focus on the bad, the good, the future, the past?"
}
for target in [companion_name]:
    for t, prompt_template in base_narrative_prompts.items():
        narrative_definitions.append({
            "type": t,
            "target": target,
            "prompt": prompt_template.format(target=target)
        })

narrative_definitions.append({
    "type": NarrativeTypes.PsychologicalAnalysis,
    "target": user_name,
    "prompt": base_narrative_prompts[NarrativeTypes.PsychologicalAnalysis].format(target=target)
})

# Inside DynamicMemoryConsolidator class or accessible to it
narrative_feature_relevance_map: Dict[NarrativeTypes, List[FeatureType]] = {
    NarrativeTypes.AttentionFocus: [
        FeatureType.Dialogue,
        FeatureType.AttentionFocus,
        FeatureType.MemoryRecall,
        FeatureType.Dialogue,  # What triggered focus shifts
        FeatureType.SubjectiveExperience,  # What was being experienced
    ],
    NarrativeTypes.SelfImage: [
        FeatureType.SubjectiveExperience,
        FeatureType.Feeling,
        FeatureType.Dialogue,
        FeatureType.Action,
        FeatureType.ExpectationOutcome,  # Reactions to expectations met/failed
        FeatureType.NarrativeUpdate,  # Direct learning about self
    ],
    NarrativeTypes.PsychologicalAnalysis: [  # Broader view
        FeatureType.SubjectiveExperience,
        FeatureType.Feeling,
        FeatureType.Action,
        FeatureType.ExpectationOutcome,
        FeatureType.MemoryRecall,
        FeatureType.Dialogue,
        FeatureType.NarrativeUpdate,
    ],
    NarrativeTypes.Relations: [
        FeatureType.Dialogue,  # How they speak to each other
        FeatureType.Feeling,  # Especially affection, trust
        FeatureType.Action,  # Actions taken towards/regarding the other
        FeatureType.ExpectationOutcome,  # Reactions involving the other person
        FeatureType.MemoryRecall,  # Memories about the relationship
        FeatureType.SubjectiveExperience,  # Experiences related to the other
    ],
    NarrativeTypes.ConflictResolution: [
        FeatureType.Dialogue,  # Arguments, apologies, negotiations
        FeatureType.Action,  # Avoidance, confrontation, problem-solving
        FeatureType.Feeling,  # Anxiety, valence shifts during conflict
        FeatureType.ExpectationOutcome,  # How unmet expectations in conflict are handled
        FeatureType.SubjectiveExperience,  # Internal experience during disagreement
    ],
    NarrativeTypes.EmotionalTriggers: [
        FeatureType.Dialogue,  # The triggering event/dialogue
        FeatureType.Feeling,  # The resulting strong emotion
        FeatureType.MemoryRecall,  # Associated past events
        FeatureType.ExpectationOutcome,  # Strong reactions to specific outcomes
        FeatureType.SubjectiveExperience,  # The raw feel of being triggered
    ],
    NarrativeTypes.GoalsIntentions: [
        # FeatureType.IntentionKnoxel? - If you make Intention a Feature type
        FeatureType.Action,  # Actions reveal underlying goals
        FeatureType.Dialogue,  # Stated goals or desires
        FeatureType.SubjectiveExperience,  # Mentions of wanting/needing something
    ],
    NarrativeTypes.BehaviorActionSelection: [
        FeatureType.Dialogue,
        FeatureType.Action,  # The chosen actions
        FeatureType.ActionSimulation,  # Considered alternatives (if stored as features)
        FeatureType.ActionRating,  # How alternatives were rated (if stored as features)
        FeatureType.Feeling,  # Emotions influencing choices
        FeatureType.ExpectationOutcome,  # Learning from past action outcomes
        FeatureType.SubjectiveExperience,  # Rationale/feeling before acting
    ]
}


class Narrative(KnoxelBase):
    narrative_type: NarrativeTypes  # Use the specific Enum
    target_name: str  # Who this narrative is about (companion_name or user_name)
    content: str
    last_refined_with_tick: Optional[int] = Field(default=None, description="The tick ID up to which features were considered for this narrative version.")


class Feature(KnoxelBase):
    feature_type: FeatureType
    source: str
    affective_valence: Optional[float] = None
    incentive_salience: Optional[float] = None
    interlocus: float  # -1 internal, +1 external, 0 mixed/neutral
    causal: bool = False  # affects story generation?

    def __str__(self):
        return f"{self.__class__.__name__} ({self.feature_type}): {self.content}"

    def get_story_element(self, ghost: KnoxelHaver = None) -> str:
        story_map = {
            # Dialogue: Keep as is - standard format
            FeatureType.Dialogue: f'{self.source} says: {QUOTE_START}{self.content}{QUOTE_END}',
            FeatureType.Feeling: f'*{self.source} felt {self.content}.*',  # Assumes content is now "a warm connection" not "<'...'
            FeatureType.SubjectiveExperience: f'*{self.content}*',  # Content should already be narrative
            FeatureType.AttentionFocus: f'*({self.source}\'s attention shifted towards: {self.content})*',  # Use parentheses for internal focus shifts
            FeatureType.Action: f'*{self.source} decided to {self.__class__.__name__.lower()}.*',  # Describe the *type* of action taken
            FeatureType.MemoryRecall: f'*({self.source} recalled: {self.content})*',
            FeatureType.SituationalModel: f'*({self.source} considered the situation: {self.content})*',
            FeatureType.ExpectationOutcome: f'*({self.content})*',  # Content should be the descriptive reaction
            FeatureType.NarrativeUpdate: f'*({self.source} reflected on the narrative: {self.content})*',
            FeatureType.StoryWildcard: f'*{self.content}*',  # General narrative element
            FeatureType.Expectation: f'*({self.source} expects: {self.content})*',
            FeatureType.Goal: f'*{self.source} has a goal: {self.content}*',
            FeatureType.Narrative: f'*{self.source} traits come to show: {self.content}*',
            FeatureType.Thought: f'{self.source} thinks: *{self.content}*',
            FeatureType.MetaInsight: f'{self.source} reflects on their own cognition: *{self.content}*',
            FeatureType.SystemMessage: f"{companion_name}'s SYSTEM-Agent reports: *{self.content}*",
            FeatureType.ExternalThought: f'{self.source} thinks: *{self.content}*',
        }
        # Default fallback
        return story_map[self.feature_type]


# --- KnoxelList Wrapper (Unchanged) ---
class KnoxelList:
    def __init__(self, knoxels: Optional[List[KnoxelBase]] = None):
        self._list = Enumerable(knoxels if knoxels else [])

    def to_json(self):
        lst = ",".join(self._list.to_list())
        return f"[{lst}]"

    def get_token_count(self):
        s = self.get_story(None)
        return get_token_count(s)

    def get_story(self, ghost: KnoxelHaver = None, max_tokens: Optional[int] = None) -> str:
        last_timestamp = None
        for item in self._list:
            if last_timestamp is None:
                last_timestamp = item.timestamp_world_begin

            if item.timestamp_world_begin < last_timestamp:
                raise Exception("Linear history mixed up!")
            last_timestamp = item.timestamp_world_begin

        content_list = [k.get_story_element(ghost) for k in self._list]
        current_tokens = 0
        buffer = []
        for content in content_list[::-1]:
            t = get_token_count(content)
            current_tokens += t
            if max_tokens is not None and current_tokens > max_tokens:
                break
            buffer.insert(0, content)

        narrative = "\n".join(buffer)
        return narrative

    def get_embeddings_np(self) -> Optional[np.ndarray]:
        embeddings = [k.embedding for k in self._list if k.embedding]
        if not embeddings: return None
        try:
            return np.array(embeddings)
        except ValueError:
            logging.error("Inconsistent embedding dimensions found.")
            return None

    def reverse(self, predicate) -> 'KnoxelList':
        return KnoxelList(self._list.reverse().to_list())

    def where(self, predicate) -> 'KnoxelList':
        return KnoxelList(self._list.where(predicate).to_list())

    def order_by(self, key_selector) -> 'KnoxelList':
        return KnoxelList(self._list.order_by(key_selector).to_list())

    def order_by_descending(self, key_selector) -> 'KnoxelList':
        return KnoxelList(self._list.order_by_descending(key_selector).to_list())

    def take(self, count: int) -> 'KnoxelList':
        return KnoxelList(self._list.take(count).to_list())

    def take_last(self, count: int) -> 'KnoxelList':
        items = self._list.to_list()
        return KnoxelList(items[-count:])

    def add(self, knoxel: KnoxelBase):
        self._list = Enumerable(self._list.to_list() + [knoxel])

    def to_list(self) -> List[KnoxelBase]:
        return self._list.to_list()

    def last_or_default(self, predicate=None, default=None) -> Optional[KnoxelBase]:
        return self._list.last_or_default(predicate, default)

    def first_or_default(self, predicate=None, default=None) -> Optional[KnoxelBase]:
        return self._list.first_or_default(predicate, default)

    def any(self, predicate=None):
        return self._list.any(predicate)

    def __len__(self) -> int:
        return self._list.count()

    def __iter__(self):
        for item in self._list:
            yield item
